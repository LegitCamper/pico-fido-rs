use ctap_types::authenticator::{Authenticator, Ctap1Authenticator, Ctap2Authenticator};
use ctap_types::ctap1::*;
use ctap_types::ctap2::*;

use core::sync::atomic::Ordering;
use embassy_time::{Duration, Timer};

use super::{LedState, BOOTSEL_BUTTON, LED_SIGNAL};

struct Ctap;

// For now instead of saving and reading keys from flash
// we'll just read and write to ram
impl Ctap {
    fn has_credential_id(
        &self,
        credential: &ctap_types::webauthn::PublicKeyCredentialDescriptorRef,
    ) -> bool {
        todo!()
    }
    fn get_credential_id(
        &self,
        credential: &ctap_types::webauthn::PublicKeyCredentialDescriptorRef,
    ) {
        todo!();
    }
}

impl Ctap1Authenticator for Ctap {
    fn register(
        &mut self,
        request: &register::Request<'_>,
    ) -> ctap_types::ctap1::Result<register::Response> {
        todo!()
    }

    fn authenticate(
        &mut self,
        request: &authenticate::Request<'_>,
    ) -> ctap_types::ctap1::Result<authenticate::Response> {
        todo!()
    }
}

impl Ctap2Authenticator for Ctap {
    fn get_info(&mut self) -> get_info::Response {}

    fn make_credential(
        &mut self,
        request: &make_credential::Request,
    ) -> ctap_types::Result<make_credential::Response> {
        // 1)
        if let Some(list) = &request.exclude_list {
            for cred in list {
                if self.has_credential_id(cred) && !self.get_credential_id(cred).rpld.is_empty() {
                    LED_SIGNAL.signal(LedState::Confirm);
                    while !BOOTSEL_BUTTON.load(Ordering::Relaxed) {
                        // Timer::after(Duration::from_millis(100)).await;
                    }
                    return ctap_types::Result::Err(ctap_types::ctap2::Error::CredentialExcluded);
                }
            }
        }

        // If the pubKeyCredParams parameter does not contain a valid COSEAlgorithmIdentifier value that is supported by the authenticator, terminate this procedure and return error code CTAP2_ERR_UNSUPPORTED_ALGORITHM.
        // 2)
        // Check for supported Algos and return CTAP2_ERR_UNSUPPORTED_ALGORITHM if unsupported

        // If the options parameter is present, process all the options. If the option is known but not supported, terminate this procedure and return CTAP2_ERR_UNSUPPORTED_OPTION. If the option is known but not valid for this command, terminate this procedure and return CTAP2_ERR_INVALID_OPTION. Ignore any options that are not understood. Note that because this specification defines normative behaviors for them, all authenticators MUST understand the "rk", "up", and "uv" options.

        // Optionally, if the extensions parameter is present, process any extensions that this authenticator supports. Authenticator extension outputs generated by the authenticator extension processing are returned in the authenticator data.

        // If pinAuth parameter is present and pinProtocol is 1, verify it by matching it against first 16 bytes of HMAC-SHA-256 of clientDataHash parameter using pinToken: HMAC- SHA-256(pinToken, clientDataHash).

        // If the verification succeeds, set the "uv" bit to 1 in the response.

        // If the verification fails, return CTAP2_ERR_PIN_AUTH_INVALID error.

        // If pinAuth parameter is not present and clientPin been set on the authenticator, return CTAP2_ERR_PIN_REQUIRED error.

        // If pinAuth parameter is present and the pinProtocol is not supported, return CTAP2_ERR_PIN_AUTH_INVALID.

        // If the authenticator has a display, show the items contained within the user and rp parameter structures to the user. Alternatively, request user interaction in an authenticator-specific way (e.g., flash the LED light). Request permission to create a credential. If the user declines permission, return the CTAP2_ERR_OPERATION_DENIED error.

        // Generate a new credential key pair for the algorithm specified.

        // If "rk" in options parameter is set to true:

        // If a credential for the same RP ID and account ID already exists on the authenticator, overwrite that credential.

        // Store the user parameter along the newly-created key pair.

        // If authenticator does not have enough internal storage to persist the new credential, return CTAP2_ERR_KEY_STORE_FULL.

        // Generate an attestation statement for the newly-created key using clientDataHash.

        // On success, the authenticator returns an attestation object in its response as defined in [WebAuthN]:

        // TODO: Remove this
        ctap_types::Result::Err(ctap_types::ctap2::Error::Success)
    }

    fn get_assertion(
        &mut self,
        request: &get_assertion::Request,
    ) -> ctap_types::Result<get_assertion::Response> {
    }

    fn get_next_assertion(&mut self) -> ctap_types::Result<get_assertion::Response> {}

    fn reset(&mut self) -> ctap_types::Result<()> {}

    fn client_pin(
        &mut self,
        request: &client_pin::Request,
    ) -> ctap_types::Result<client_pin::Response> {
    }

    fn credential_management(
        &mut self,
        request: &credential_management::Request,
    ) -> ctap_types::Result<credential_management::Response> {
    }

    fn selection(&mut self) -> ctap_types::Result<()> {}

    fn vendor(&mut self, op: VendorOperation) -> ctap_types::Result<()> {}
}
